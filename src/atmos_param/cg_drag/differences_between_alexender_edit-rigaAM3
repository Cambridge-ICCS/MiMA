1c1
< alexander edit
> riga version (AM3)
<                      module cg_drag_mod
---
> module cg_drag_mod
9a10,11
> use fms_io_mod,             only:  register_restart_field, restart_file_type
> use fms_io_mod,             only:  save_restart, restore_state, get_mosaic_tile_file
13c15,16
< use constants_mod,          only:  constants_init, PI, RDGAS, GRAV, CP_AIR
---
> use constants_mod,          only:  constants_init, PI, RDGAS, GRAV, CP_AIR, &
>                                    SECONDS_PER_DAY
15,17c18
< !wfc++ remove for general use
< #ifdef SKIP
< !wfc--
---
> #ifdef COL_DIAG
22,24c23
< !wfc remove for general use
< #endif SKIP
< !wfc--
---
> #endif
42,43c41,42
< character(len=128)  :: version =  '$Id: cg_drag.f90,v 13.0 2006/03/28 21:07:22 fms Exp $'
< character(len=128)  :: tagname =  '$Name: memphis $'
---
> character(len=128)  :: version =  '$Id: cg_drag.F90,v 18.0 2010/03/02 23:28:40 fms Exp $'
> character(len=128)  :: tagname =  '$Name: riga $'
50c49,50
< public    cg_drag_init, cg_drag_calc, cg_drag_end
---
> public    cg_drag_init, cg_drag_calc, cg_drag_end, cg_drag_restart, &
>           cg_drag_time_vary, cg_drag_endts
53c53,54
< private   read_restart_file, gwfc
---
> private   read_restart_file, read_nc_restart_file, &
>           write_restart_file, gwfc
54a56,60
> !--- for netcdf restart
> type(restart_file_type), pointer, save :: Cg_restart => NULL()
> type(restart_file_type), pointer, save :: Til_restart => NULL()
> logical                                :: in_different_file = .false.
> integer                                :: vers, old_time_step
59a66
>       real,     allocatable, dimension(:,:,:)   ::  gwd_u, gwd_v
146,147c153,157
< integer, dimension(2)  :: restart_versions = (/ 1, 2 /)
< 
---
> integer, dimension(3)  :: restart_versions = (/ 1, 2, 3 /)
> ! v1 :
> ! v2 : 
> ! v3 : Now use NetCDF for restart file.
> !
193,196d202
< !   pts_processed
< !                counter of current number of columns which have been
< !                processed on this step
< !   total_pts    number of columns which must be processed on each step
200c206
< integer          :: pts_processed, total_pts, cgdrag_alarm
---
> integer          :: cgdrag_alarm
227d232
< !rjw integer          :: id_ked_cgwd, id_bf_cgwd, id_gwf_cgwd
259,261c264,267
< real,    dimension(:), intent(in)      :: lonb, latb, pref
< integer, dimension(4), intent(in)      :: axes
< type(time_type),       intent(in)      :: Time
---
> real,    dimension(:,:), intent(in)      :: lonb, latb
> real,    dimension(:),   intent(in)      :: pref
> integer, dimension(4),   intent(in)      :: axes
> type(time_type),         intent(in)      :: Time
267,268c273,274
< !       lonb      array of model longitudes on cell boundaries [radians]
< !       latb      array of model latitudes at cell boundaries [radians]
---
> !       lonb      2d array of model longitudes on cell corners [radians]
> !       latb      2d array of model latitudes at cell corners [radians]
280c286
<       integer                 :: unit, ierr, io
---
>       integer                 :: unit, ierr, io, logunit
283a290
> !      real                    :: pif = PI/180.
285,287c292,293
< !wfc ++ added for definition of source_level, source_amp.
<       real, allocatable       ::   lat(:,:)
< !wfc--
---
> !      real, allocatable       :: lat(:,:)
>       real                    :: lat(size(lonb,1) - 1, size(latb,2) - 1)
314,316c320
< !wfc++ remove for general use
< #ifdef SKIP
< !wfc--
---
> #ifdef COL_DIAG
318d321
< !wfc++ remove for general use
320d322
< !wfc--
337c339,340
<       if (mpp_pe() == mpp_root_pe()) write (stdlog(), nml=cg_drag_nml)
---
>       logunit = stdlog()
>       if (mpp_pe() == mpp_root_pe()) write (logunit, nml=cg_drag_nml)
344,346c347,348
<       jdf  = size(latb(:)) - 1
<       idf  = size(lonb(:)) - 1
< 
---
>       jdf  = size(latb,2) - 1
>       idf  = size(lonb,1) - 1
348d349
< !wfc++ new code
351,353c352
< 
<       allocate(  lat(idf,jdf)  )
< !wfc--
---
> !      allocate(  lat(idf,jdf)  )
367,383c366,373
<      
< 
< !wfc++ new code
<         do j=1,jdf
<           lat(:,j)=  0.5*( latb(j+1)+latb(j) )
<           do i=1,idf
<             source_level(i,j) = (kmax + 1) - ((kmax + 1 -    &
<                                 klevel_of_source)*cos(lat(i,j)) + 0.5)
< 
< !rjw             source_amp(i,j)= Bt_0 +                         &
< !rjw                             Bt_eq*exp( -Bt_eq_width*lat(i,j)*lat(i,j) )  + &
< !rjw                             (Bt_nh-Bt_sh)*(1.0+tanh(4.0*lat(i,j)))/2.0 + Bt_sh
< 
<             source_amp(i,j) = Bt_0 +                         &
<                         Bt_nh*0.5*(1.+tanh((lat(i,j)/pif-phi0n)/dphin)) + &
<                         Bt_sh*0.5*(1.+tanh((lat(i,j)/pif-phi0s)/dphis))
<           end do
---
>       do j=1,jdf
>         lat(:,j)=  0.5*( latb(:,j+1)+latb(:,j) )
>         do i=1,idf
>           source_level(i,j) = (kmax + 1) - ((kmax + 1 -    &
>                               klevel_of_source)*cos(lat(i,j)) + 0.5)
>           source_amp(i,j) = Bt_0 +                         &
>                       Bt_nh*0.5*(1.+tanh((lat(i,j)/pif-phi0n)/dphin)) + &
>                       Bt_sh*0.5*(1.+tanh((lat(i,j)/pif-phi0s)/dphis))
385c375,376
<         source_level = MIN (source_level, kmax-1)
---
>       end do
>       source_level = MIN (source_level, kmax-1)
387,388c378
<        deallocate( lat )
< !wfc--
---
> !      deallocate( lat )
403,405c393
< !wfc++ remove for general use.
< #ifdef SKIP
< !wfc--
---
> #ifdef COL_DIAG
431c419
<                       lon_coords_gl, lonb, latb, do_column_diagnostics, &
---
>                       lon_coords_gl, lonb(:,1), latb(1,:), do_column_diagnostics, &
434,436c422
< !wfc++ remove for general use.
< #endif SKIP
< !wfc--
---
> #endif
468,472d453
< !rjw      id_gwf_cgwd =  &
< !rjw         register_diag_field (mod_name, 'gwf_cgwd', axes(1:3), Time, &
< !rjw              'gravity wave forcing on mean flow', &
< !rjw              'm/s^2',  missing_value=missing_value)
< 
481,488c462
< !wfc++ remove
< !!!      if (calculate_ked) then
< !wfc--
< !rjw        id_ked_cgwd =  &
< !rjw         register_diag_field (mod_name, 'ked_cgwd', axes(1:3), Time, &
< !rjw               'effective eddy viscosity from cg_drag', 'm^2/s',   &
< !rjw               missing_value=missing_value)
<         id_kedx_cgwd =  &
---
>       id_kedx_cgwd =  &
492c466
<         id_kedy_cgwd =  &
---
>       id_kedy_cgwd =  &
496,504d469
< !wfc++ remove
< !!!      endif
< !wfc--
< !---------------------------------------------------------------------
< !    initialize counters needed when cg_drag is not calculated on every
< !    time step. 
< !---------------------------------------------------------------------
<       total_pts = idf*jdf
<       pts_processed = 0
510,518c475,476
< !wfc++ remove as calculate_ked no longer used
< #ifdef SKIP2
<      allocate ( gwd(idf,jdf,kmax) )
<       if (calculate_ked) then
<         allocate ( ked(idf,jdf,kmax) )
<         ked(:,:,:) = 0.0
<       endif
< #endif SKIP2
< !wfc--
---
>      allocate ( gwd_u(idf,jdf,kmax) )
>      allocate ( gwd_v(idf,jdf,kmax) )
520,522d477
< !wfc++ remove for general use
< #ifdef SKIP 
< !wfc--
526,527c481,486
<       if (file_exist('INPUT/cg_drag.res')) then
<         call read_restart_file
---
>       if (size(restart_versions(:)) .gt. 2 ) then
>         call cg_drag_register_restart
>       endif
> 
>       if (file_exist('INPUT/cg_drag.res.nc')) then
>         call read_nc_restart_file
528a488,489
>       elseif (file_exist('INPUT/cg_drag.res')) then
>         call read_restart_file
535c496,497
<         gwd(:,:,:) = 0.0
---
>         gwd_u(:,:,:) = 0.0
>         gwd_v(:,:,:) = 0.0
539c501
<           cgdrag_alarm = cg_drag_freq  
---
>           cgdrag_alarm = cg_drag_freq
542,544c504,505
< !wfc++ remove for general use
< #endif
< !wfc--
---
>       vers = restart_versions(size(restart_versions(:)))
>       old_time_step = cgdrag_alarm 
556a518,548
> !####################################################################
>  
> subroutine cg_drag_time_vary (delt)
> 
> real           ,        intent(in)      :: delt
> 
> !---------------------------------------------------------------------
> !    decrement the time remaining until the next cg_drag calculation.
> !---------------------------------------------------------------------
>       cgdrag_alarm = cgdrag_alarm - delt
> 
> !---------------------------------------------------------------------
>  
> end subroutine cg_drag_time_vary
> 
> 
> !####################################################################
>  
> subroutine cg_drag_endts
>  
> !--------------------------------------------------------------------
> !    if this was a calculation step, reset cgdrag_alarm to indicate 
> !    the time remaining before the next calculation of gravity wave 
> !    forcing.
> !--------------------------------------------------------------------
>       if (cgdrag_alarm <= 0 ) then
>         cgdrag_alarm = cgdrag_alarm + cg_drag_freq
>       endif
> 
> end subroutine cg_drag_endts
> 
560,562d551
< !wfc++ need to add iloc, jloc?
< !rjw  subroutine cg_drag_calc (is, js, lat, pfull, zfull,    &
< !rjw                          temp, uuu, Time, delt, gwfcng)
565d553
< !wfc--
576,578d563
< !wfc++ new arguments not in interface
< !rjw integer,                intent(in)      :: iloc, jloc
< !wfc--
583d567
< !rjw real, dimension(:,:,:), intent(out)     :: gwfcng
595a580
> !       vvv      meridional wind  [ m/s ]
601c586,588
< !       gwfcng   time tendency for u eqn due to gravity-wave forcing
---
> !       gwfcng_x time tendency for u eqn due to gravity-wave forcing
> !                [ m/s^2 ]
> !       gwfcng_y time tendency for v eqn due to gravity-wave forcing
617,626d603
< #ifdef SKIP
< !rjw    These should be removed since they are allocated in init
<       integer, dimension (size(uuu,1), size(uuu,2))               ::  &
<                                          source_level
< 
<       real   , dimension (size(uuu,1), size(uuu,2))               ::  &
<                                          source_amp
< #endif SKIP
< 
< 
633a611
> !      real              :: pif = PI/180.
672,679d649
< !    if this is the first entry into this module on this timestep,
< !    decrement the time remaining until the next cg_drag calculation.
< !---------------------------------------------------------------------
<       if (pts_processed == 0) then
<         cgdrag_alarm = cgdrag_alarm - delt
<       endif
< 
< !---------------------------------------------------------------------
686,701c656
< !wfc++ no alarm anymore?
< !!!rjw      if (cgdrag_alarm <= 0) then
< !wfc--
< 
< !----------------------------------------------------------------------
< !    define the source level for gravity waves for each model column. 
< !    it will be highest at equator and lowest near the poles. prevent 
< !    it from being the lowest model level (which will occur only very 
< !    near the poles with the current formulation.)
< !----------------------------------------------------------------------
< !wfc++ remove as these are constant.
< #ifdef SKIP
<         do j=1,jmax
<           do i=1,imax
<             source_level(i,j) = (kmax + 1) - ((kmax + 1 -    &
<                                 klevel_of_source)*cos(lat(i,j)) + 0.5)
---
>       if (cgdrag_alarm <= 0) then
703,710d657
<             source_amp(i,j)= Bt_0 +                         &
<                              Bt_eq*exp( -Bt_eq_width*lat(i,j)*lat(i,j) )  + &
<                              (Bt_nh-Bt_sh)*(1.0+tanh(4.0*lat(i,j)))/2.0 + Bt_sh
<           end do
<         end do
<         source_level = MIN (source_level, kmax-1)
< #endif
< !!wfc-- 
719c666,667
<             iz0 = source_level(i,j)
---
> ! The following index-offsets are needed in case a physics_window is being used.
>             iz0 = source_level(i +is-1,j+js-1)
790,803d737
< !wfc++ Remove as the code is obsolete.
< #ifdef SKIP
<         if (calculate_ked) then
<           call gwfc (is, ie, js, je, source_level, source_amp,    &
<                      zden, zu, zbf,zzchm, gwd_xtnd, ked_xtnd)
<           gwfcng(:,:,1:kmax) = gwd_xtnd(:,:,1:kmax  )
<           ked_gwfc(:,:,1:kmax) = ked_xtnd(:,:,1:kmax  )
<         else
<           call gwfc (is, ie, js, je, source_level, source_amp,    &
<                      zden, zu, zbf, zzchm, gwd_xtnd)
<           gwfcng(:,:,1:kmax) = gwd_xtnd(:,:,1:kmax  )
<         endif
< #else 
< !wfc--
807c741
<           gwfcng_x  (:,:,1:kmax) = gwd_xtnd(:,:,1:kmax  )
---
>          gwfcng_x  (:,:,1:kmax) = gwd_xtnd(:,:,1:kmax  )
815,828c749,753
< 
< !wfc++ Remove this test code
< #endif SKIP 
< 
< 
< #ifdef SKIP
<        DO i= 1, imax
<          DO j= 1, jmax
<            DO k= 1, kmax
<               gwfcng(i,j,k)= 1.0*( i + (js+j-2)*60.0 + (k-1)*60.0*36.0 )
<             ENDDO
<           ENDDO
<         ENDDO
< #endif SKIP
---
> !--------------------------------------------------------------------
> !    store the gravity wave forcing into a processor-global array.
> !-------------------------------------------------------------------
>           gwd_u(is:ie,js:je,:) = gwfcng_x(:,:,:)
>           gwd_v(is:ie,js:je,:) = gwfcng_y(:,:,:)
831,832c756
< #ifdef SKIP
< !wfc --
---
> #ifdef COL_DIAG
871,873c795
< !wfc++ remove for general use
< #endif SKIP
< !wfc--
---
> #endif
875,881d796
< !--------------------------------------------------------------------
< !    store the gravity wave forcing into a processor-global array.
< !-------------------------------------------------------------------
< !wfc++ Not needed as calculate_ked is gone.
< !!!   rjw   Not needed as we have eliminated restart files 
< !!!rjw        gwd(is:ie,js:je,:) = gwfcng(:,:,:)
< !wfc
888,903d802
< !wfc++ remove as calculate_ked is gone
< #ifdef SKIP
<         if (calculate_ked) then
<           ked(is:ie, js:je,:) = ked_gwfc(:,:,:)
<           if (id_ked_cgwd > 0) then
<             used = send_data (id_ked_cgwd, ked_gwfc, Time, iloc, jloc)
<           endif
<         endif
< #endif SKIP
< !wfc--
< 
< !rjw          if (id_ked_cgwd > 0) then
< !wfc++ iloc,jloc used.
< !rjw            used = send_data (id_ked_cgwd, ked_gwfc, Time, iloc, jloc)
< !wfc--
< !rjw          endif
919,920d817
< !wfc++ iloc, jloc
< !rjw          used = send_data (id_bf_cgwd,  zbf(:,:,1:), Time, iloc, jloc )
922d818
< !wfc--
924,928d819
< ! rjw        if (id_gwf_cgwd > 0) then
< !wfc++ iloc, jloc
< ! rjw          used = send_data (id_gwf_cgwd, gwfcng, Time, iloc, jloc )
< !wfc--
< ! rjw        endif
944,967c835,838
< !wfc++ no alarms anymore? 
< !!!rjw      else   ! (cgdrag_alarm <= 0)
< !!!rjw        gwfcng(:,:,:) = gwd(is:ie,js:je,:)
< !!!rjw     endif  ! (cgdrag_alarm <= 0)
< !wfc--
< 
< !--------------------------------------------------------------------
< !    increment the number of points processed on this time step, and 
< !    if all points have now been processed and this was a calculation
< !    step, reset cgdrag_alarm to indicate the time remaining before the
< !    next calculation of gravity wave forcing.
< !--------------------------------------------------------------------
< #ifdef SKIP 
<       pts_processed = pts_processed + size(gwfcng,1)*size(gwfcng,2)
<       if (pts_processed == total_pts) then
<         pts_processed = 0
< !wfc++ If alarm is removed above, no need to set it here.
<         if (cgdrag_alarm <= 0 ) then
<            cgdrag_alarm = cgdrag_alarm + cg_drag_freq
<         endif
< !wfc--
<       endif
< #endif 
< 
---
>       else   ! (cgdrag_alarm <= 0)
>         gwfcng_x(:,:,:) = gwd_u(is:ie,js:je,:)
>         gwfcng_y(:,:,:) = gwd_v(is:ie,js:je,:)
>      endif  ! (cgdrag_alarm <= 0)
988c859,894
<       integer :: unit     ! unit for writing restart file
---
> !For version 3 and after, use NetCDF restarts.
>       if (mpp_pe() == mpp_root_pe() ) &
>             call error_mesg ('cg_drag_mod', 'write_restart_nc: &
>               &Writing netCDF formatted restart file as &
>                 &requested. ', NOTE)
>       call cg_drag_restart
> 
> 
> #ifdef COL_DIAG
>       if (column_diagnostics_desired) then
>         call close_column_diagnostics_units (diag_units)
>       endif
> #endif
> 
> !---------------------------------------------------------------------
> !    mark the module as uninitialized.
> !---------------------------------------------------------------------
>       module_is_initialized = .false.
> 
> !---------------------------------------------------------------------
> 
> 
> end subroutine cg_drag_end
> 
> 
> 
> !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> !
> !                     PRIVATE SUBROUTINES
> !
> !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
> 
> 
> subroutine  write_restart_file
> 
> integer :: unit     ! unit for writing restart file
990,992d895
< !wfc++ remove for general use
< #ifdef SKIP2
< !wfc--
1012c915
<       call write_data (unit, gwd)
---
>       call write_data (unit, gwd_u)
1019,1049d921
< !wfc++ remove for general use
< #endif SKIP2
< 
< #ifdef SKIP
< !wfc--
<       if (column_diagnostics_desired) then
<         call close_column_diagnostics_units (diag_units)
<       endif
< !wfc++ remove for general use
< #endif SKIP
< !wfc--
< 
< !---------------------------------------------------------------------
< !    mark the module as uninitialized.
< !---------------------------------------------------------------------
<       module_is_initialized = .false.
< 
< !---------------------------------------------------------------------
< 
< 
< end subroutine cg_drag_end
< 
< 
< 
< 
< !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
< !
< !                     PRIVATE SUBROUTINES
< !
< !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
< 
1050a923
> end subroutine write_restart_file
1066,1069c939,940
<       integer                 :: vers
<       integer, dimension(5)   :: null
<       integer                 :: old_time_step
<       real                    :: secs_per_day = 86400.
---
>       integer, dimension(5)   :: dummy
>       real                    :: secs_per_day = SECONDS_PER_DAY
1077c948
< !       null           array to hold restart version 1 control variables
---
> !       dummy          array to hold restart version 1 control variables
1084,1087d954
< !wfc++ remove for general use
< #ifdef SKIP
< !wfc--
< 
1110c977
< !    if reading restart version 1, use the contents of array null to
---
> !    if reading restart version 1, use the contents of array dummy to
1117,1118c984,985
<         read (unit) null           
<         old_time_step = secs_per_day*null(4) + null(3)
---
>         read (unit) dummy           
>         old_time_step = secs_per_day*dummy(4) + dummy(3)
1137c1004,1005
<       call read_data (unit, gwd)
---
>       call read_data (unit, gwd_u)
>       gwd_v(:,:,:) = 0.0
1152,1154d1019
< !wfc++ remove for general use
< #endif SKIP
< !wfc--
1173a1039,1162
> subroutine read_nc_restart_file
> !-----------------------------------------------------------------------
> !    subroutine read_restart_nc reads a netcdf restart file to obtain 
> !    the variables needed upon experiment restart. 
> !-----------------------------------------------------------------------
> 
> !---------------------------------------------------------------------
> !   local variables:
> 
>       character(len=64)     :: fname='INPUT/cg_drag.res.nc'
>       character(len=8)      :: chvers
>       integer, dimension(5) :: dummy
>       real                  :: secs_per_day = SECONDS_PER_DAY
> 
> !---------------------------------------------------------------------
> !   local variables:
> !
> !        fname            restart file name
> !
> !----------------------------------------------------------------------
> 
> !--------------------------------------------------------------------
> !    output a message indicating entrance into this routine.
> !--------------------------------------------------------------------
>       if (mpp_pe() == mpp_root_pe() ) then
>         call error_mesg ('cg_drag_mod',  'read_restart_nc:&
>              &Reading netCDF formatted restart file:'//trim(fname), NOTE)
>       endif
> 
> !-------------------------------------------------------------------
> !    read the values of gwd_u and gwd_v
> !-------------------------------------------------------------------
>       if (size(restart_versions(:)) .le. 2 ) then
>          call error_mesg ('cg_drag_mod',  'read_restart_nc: restart file format is netcdf, ' // &
>               'restart_versions is not netcdf file version', FATAL)
>       endif
>       call restore_state(Cg_restart)
>       if(in_different_file) call restore_state(Til_restart)
>       if (.not. any(vers == restart_versions) ) then
>         write (chvers, '(i4)') vers
>         call error_mesg ('cg_drag_init', &
>                'restart version '//chvers//' cannot be read &
>                &by this module version', FATAL)
>       endif
>       vers = restart_versions(size(restart_versions(:)))
> 
> !--------------------------------------------------------------------
> !    if current cg_drag calling frequency differs from that previously 
> !    used, adjust the time remaining before the next calculation. 
> !--------------------------------------------------------------------
>       if (cg_drag_freq /= old_time_step) then
>         cgdrag_alarm = cgdrag_alarm - old_time_step + cg_drag_freq
>         if (mpp_pe() == mpp_root_pe() ) then
>           call error_mesg ('cg_drag_mod',   &
>                 'cgdrag time step has changed, &
>                 &next cgdrag time also changed', NOTE)
>         endif
>         old_time_step = cg_drag_freq
>       endif
> 
> !--------------------------------------------------------------------
> !    if cg_drag_offset is specified and is smaller than the time remain-
> !    ing until the next calculation, modify the time remaining to be 
> !    that offset time. the assumption is made that the restart was
> !    written at 00Z.
> !--------------------------------------------------------------------
>       if (cg_drag_offset /= 0) then
>         if (cgdrag_alarm > cg_drag_offset) then
>           cgdrag_alarm = cg_drag_offset
>         endif
>       endif
> 
> !---------------------------------------------------------------------
> end subroutine read_nc_restart_file
> 
> !####################################################################
> ! register restart field to be read and written through save_restart and restore_state.
> subroutine cg_drag_register_restart
> 
>   character(len=64) :: fname = 'cg_drag.res.nc'    ! name of restart file
>   character(len=64) :: fname2 
>   integer           :: id_restart
> 
>   call get_mosaic_tile_file(fname, fname2, .false. ) 
>   allocate(Cg_restart)
>   if(trim(fname2) == trim(fname)) then
>      Til_restart => Cg_restart
>      in_different_file = .false.
>   else
>      in_different_file = .true.
>      allocate(Til_restart)
>   endif
> 
>   id_restart = register_restart_field(Cg_restart, fname, 'restart_version', vers)
>   id_restart = register_restart_field(Cg_restart, fname, 'cgdrag_alarm', cgdrag_alarm)
>   id_restart = register_restart_field(Cg_restart, fname, 'cg_drag_freq', old_time_step)
>   id_restart = register_restart_field(Til_restart, fname, 'gwd_u', gwd_u)
>   id_restart = register_restart_field(Til_restart, fname, 'gwd_v', gwd_v)
> 
>   return
> 
> end subroutine cg_drag_register_restart
> 
> !####################################################################
> ! <SUBROUTINE NAME="cg_drag_restart">
> !
> ! <DESCRIPTION>
> ! write out restart file.
> ! Arguments: 
> !   timestamp (optional, intent(in)) : A character string that represents the model time, 
> !                                      used for writing restart. timestamp will append to
> !                                      the any restart file name as a prefix. 
> ! </DESCRIPTION>
> !
> subroutine cg_drag_restart(timestamp)
>   character(len=*), intent(in), optional :: timestamp
> 
>   call save_restart(Cg_restart, timestamp)
>   if(in_different_file) call save_restart(Til_restart, timestamp)
> 
> end subroutine cg_drag_restart
> ! </SUBROUTINE> NAME=cg_drag_restart"
> 
> 
1193,1196c1182
< !wfc++ remove obsolete code
< !!!rjw  real,    dimension(:,:,0:),  intent(out), optional  :: ked
< !wfc--
< real,    dimension(:,:,0:),  intent(out)  :: ked
---
> real,    dimension(:,:,0:),  intent(out)            :: ked
1283,1289c1269
< !wfc++ remove obsolete code
< !!!rjw      if (present(ked)) then
< !wfc--
<         ked = 0.0
< !wfc++ remove obsolete code
< !!!rjw      endif
< !wfc--
---
>       ked = 0.0
1293,1294c1273,1275
<           iz0 = source_level(i,j)
<           ampl= source_amp(i,j)
---
> ! The following index-offsets are needed in case a physics_window is being used.
>           iz0 = source_level(i+is-1,j+js-1)
>           ampl= source_amp(i+is-1,j+js-1)
1337d1317
< !!          eps = (Bt_0*1.5/nk)/Bsum
1420,1426c1400
< !wfc++ remove obsolete code
< !!!rjw                          if (calculate_ked) then
< !wfc--
<                             fe = fe + c0mu(k)*B0(n)
< !wfc++ remove obsolete code
< !!!rjw                          endif
< !wfc--
---
>                           fe = fe + c0mu(k)*B0(n)
1443,1452c1417,1420
< !wfc++ remove obsolete code
< !!!rjw                if (calculate_ked) then
< !wfc--
<                   diff_coeff(k) = (rho(i,j,iz0)/rbh)*fe*eps/(dz(k)*   &
<                             bf(i,j,k)*bf(i,j,k))
<                   diff_coeff(k+1) = 0.5*(diff_coeff(k+1) +    &
<                                          diff_coeff(k))
< !wfc++ remove obsolete code
< !!!rjw                endif
< !wfc--
---
>                 diff_coeff(k) = (rho(i,j,iz0)/rbh)*fe*eps/(dz(k)*   &
>                                  bf(i,j,k)*bf(i,j,k))
>                 diff_coeff(k+1) = 0.5*(diff_coeff(k+1) +    &
>                                        diff_coeff(k))
1455,1461c1423
< !wfc++ remove obsolete code
< !!!rjw                if (calculate_ked) then
< !wfc--
<                   diff_coeff(iz0) = 0.0
< !wfc++ remove obsolete code
< !!!rjw                endif
< !wfc--
---
>                 diff_coeff(iz0) = 0.0
1471,1477c1433
< !wfc++ remove obsolete code
< !!!rjw              if (present(ked)) then
< !wfc--
<                 ked(i,j,k) = ked(i,j,k) + diff_coeff(k)
< !wfc++ remove obsolete code
< !!!rjw              endif
< !wfc--
---
>               ked(i,j,k) = ked(i,j,k) + diff_coeff(k)
1494c1450
<                     end module cg_drag_mod
---
> end module cg_drag_mod
